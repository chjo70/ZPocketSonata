/* Copyright (c) 2014-2016 Wind River Systems, Inc.
 *
 * The right to copy, distribute, modify or otherwise make use
 * of this software may be licensed only pursuant to the terms
 * of an applicable Wind River license agreement.
 */

/* This file has been autogenerated by cafe-type2h(1). */

#ifndef CAFE_TYPE2H_CAFE_AGGREGATOR_TYPE_autogenerated_h
#define CAFE_TYPE2H_CAFE_AGGREGATOR_TYPE_autogenerated_h

#include <cafe/autogenerated/cafe.type.h>

#ifdef __cplusplus
extern "C" {
#endif

#define cafe_AGGREGATE_TYPE_VT_DEF "N[cafe.AGGREGATE_TYPE]"
#define cafe_AGGREGATE_TYPE_VT_REF "t[cafe.AGGREGATE_TYPE]"
#define cafe_AGGREGATE_TYPE_VT_NAT "n[cafe.AGGREGATE_TYPE]"

#define cafe_AVG_VT_DEF "N[cafe.AVG,,n[cafe.AGGREGATE_TYPE]]"
#define cafe_AVG_VT_REF "t[cafe.AVG]"
#define cafe_AVG_VT_NAT "n[cafe.AVG]"

#define cafe_CUMULATIVE_VT_DEF "N[cafe.CUMULATIVE,,n[cafe.AGGREGATE_TYPE]]"
#define cafe_CUMULATIVE_VT_REF "t[cafe.CUMULATIVE]"
#define cafe_CUMULATIVE_VT_NAT "n[cafe.CUMULATIVE]"

#define cafe_MAX_VT_DEF "N[cafe.MAX,,n[cafe.AGGREGATE_TYPE]]"
#define cafe_MAX_VT_REF "t[cafe.MAX]"
#define cafe_MAX_VT_NAT "n[cafe.MAX]"

#define cafe_MIN_VT_DEF "N[cafe.MIN,,n[cafe.AGGREGATE_TYPE]]"
#define cafe_MIN_VT_REF "t[cafe.MIN]"
#define cafe_MIN_VT_NAT "n[cafe.MIN]"

#define cafe_SET_VT_DEF "N[cafe.SET,,n[cafe.AGGREGATE_TYPE]]"
#define cafe_SET_VT_REF "t[cafe.SET]"
#define cafe_SET_VT_NAT "n[cafe.SET]"

#define cafe_SUM_VT_DEF "N[cafe.SUM,,n[cafe.AGGREGATE_TYPE]]"
#define cafe_SUM_VT_REF "t[cafe.SUM]"
#define cafe_SUM_VT_NAT "n[cafe.SUM]"

#define cafe_TABLE_NAME_VT_DEF "N[cafe.TABLE_NAME,v[name,s]]"
#define cafe_TABLE_NAME_VT_REF "t[cafe.TABLE_NAME]"
#define cafe_TABLE_NAME_VT_NAT "n[cafe.TABLE_NAME]"

#define cafe_avgval_Q_VT_DEF "S[cafe.avgval_Q,v[count,Q]v[total,Q]]"
#define cafe_avgval_Q_VT_REF "t[cafe.avgval_Q]"

#define cafe_avgval_d_VT_DEF "S[cafe.avgval_d,v[count,q]v[total,d]]"
#define cafe_avgval_d_VT_REF "t[cafe.avgval_d]"

#define cafe_avgval_q_VT_DEF "S[cafe.avgval_q,v[count,q]v[total,q]]"
#define cafe_avgval_q_VT_REF "t[cafe.avgval_q]"

#define cafe_memory_map_generation_VT_DEF "N[cafe.memory_map_generation]"
#define cafe_memory_map_generation_VT_REF "t[cafe.memory_map_generation]"
#define cafe_memory_map_generation_VT_NAT "n[cafe.memory_map_generation]"

#define cafe_sequence_VT_DEF "S[cafe.sequence,v[end,L,n[cafe.SET]]v[count,L,n[cafe.SUM]]]"
#define cafe_sequence_VT_REF "t[cafe.sequence]"

#define cafe_setval_Q_VT_DEF "S[cafe.setval_Q,v[is_set,?]v[value,Q]]"
#define cafe_setval_Q_VT_REF "t[cafe.setval_Q]"

#define cafe_setval_b_VT_DEF "S[cafe.setval_b,v[is_set,?]v[value,b]]"
#define cafe_setval_b_VT_REF "t[cafe.setval_b]"

#define cafe_setval_bool_VT_DEF "S[cafe.setval_bool,v[is_set,?]v[value,?]]"
#define cafe_setval_bool_VT_REF "t[cafe.setval_bool]"

#define cafe_setval_d_VT_DEF "S[cafe.setval_d,v[is_set,?]v[value,d]]"
#define cafe_setval_d_VT_REF "t[cafe.setval_d]"

#define cafe_setval_q_VT_DEF "S[cafe.setval_q,v[is_set,?]v[value,q]]"
#define cafe_setval_q_VT_REF "t[cafe.setval_q]"

#define cafe_setval_s_VT_DEF "S[cafe.setval_s,v[is_set,?]v[value,s]]"
#define cafe_setval_s_VT_REF "t[cafe.setval_s]"

#define cafe_start_VT_DEF "S[cafe.start]"
#define cafe_start_VT_REF "t[cafe.start]"

#define cafe_stop_VT_DEF "S[cafe.stop]"
#define cafe_stop_VT_REF "t[cafe.stop]"

#define cafe_aggregator_BUCKETING_VT_DEF "N[cafe_aggregator.BUCKETING,,n[cafe.CAPABILITY]]"
#define cafe_aggregator_BUCKETING_VT_REF "t[cafe_aggregator.BUCKETING]"
#define cafe_aggregator_BUCKETING_VT_NAT "n[cafe_aggregator.BUCKETING]"

#define cafe_aggregator_SYMRESOLVE_VT_DEF "N[cafe_aggregator.SYMRESOLVE,,n[cafe.CAPABILITY]]"
#define cafe_aggregator_SYMRESOLVE_VT_REF "t[cafe_aggregator.SYMRESOLVE]"
#define cafe_aggregator_SYMRESOLVE_VT_NAT "n[cafe_aggregator.SYMRESOLVE]"

#define cafe_aggregator_aggregator_VT_DEF "S[cafe_aggregator.aggregator]"
#define cafe_aggregator_aggregator_VT_REF "t[cafe_aggregator.aggregator]"

#define CAFE_AGGREGATOR_TYPE_ALL_VT_DEFS \
	cafe_AGGREGATE_TYPE_VT_DEF \
	cafe_AVG_VT_DEF \
	cafe_CUMULATIVE_VT_DEF \
	cafe_MAX_VT_DEF \
	cafe_MIN_VT_DEF \
	cafe_SET_VT_DEF \
	cafe_SUM_VT_DEF \
	cafe_TABLE_NAME_VT_DEF \
	cafe_avgval_Q_VT_DEF \
	cafe_avgval_d_VT_DEF \
	cafe_avgval_q_VT_DEF \
	cafe_memory_map_generation_VT_DEF \
	cafe_sequence_VT_DEF \
	cafe_setval_Q_VT_DEF \
	cafe_setval_b_VT_DEF \
	cafe_setval_bool_VT_DEF \
	cafe_setval_d_VT_DEF \
	cafe_setval_q_VT_DEF \
	cafe_setval_s_VT_DEF \
	cafe_start_VT_DEF \
	cafe_stop_VT_DEF \
	cafe_aggregator_BUCKETING_VT_DEF \
	cafe_aggregator_SYMRESOLVE_VT_DEF \
	cafe_aggregator_aggregator_VT_DEF \

struct cafe_avgval_Q {
	unsigned long long count;
	unsigned long long total;
};

struct cafe_avgval_d {
	long long count;
	double total;
};

struct cafe_avgval_q {
	long long count;
	long long total;
};

/**
 * cafe.sequence - specifies the event sequence number
 *
 * This event specifies the sequence number of an event.  This is
 * intended to be an orthogonal event.  The sequence number is very
 * useful to guarantee the exact event order when events are stored in
 * multiple logs, for example in a multi-core system where each core
 * might have its own log to reduce core synchronization when
 * inserting the event in the log.  The timestamp may not have high
 * enough resolution to guarantee exact event ordering.
 *
 * How the sequence number is produced is up to the implementation. One
 * way to produce it is to have a global variable that is accessible by
 * all cores or memory spaces involved that is atomically incremented
 * every time an event is generated.
 */
struct cafe_sequence {
	unsigned long end;
	unsigned long count;
};

struct cafe_setval_Q {
	bool is_set;
	unsigned long long value;
};

struct cafe_setval_b {
	bool is_set;
	struct cafe_vm_blob value;
};

struct cafe_setval_bool {
	bool is_set;
	bool value;
};

struct cafe_setval_d {
	bool is_set;
	double value;
};

struct cafe_setval_q {
	bool is_set;
	long long value;
};

struct cafe_setval_s {
	bool is_set;
	char *value;
};

#ifdef __cplusplus
}
#endif /* __cplusplus */

#endif
