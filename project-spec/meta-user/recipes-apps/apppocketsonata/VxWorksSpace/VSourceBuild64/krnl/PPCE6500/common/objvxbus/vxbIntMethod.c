/*
 * Copyright (c) 2021 Wind River Systems, Inc.
 *
 * The right to copy, distribute, modify or otherwise make use
 * of this software may be licensed only pursuant to the terms
 * of an applicable Wind River license agreement.
 */

/*
 *  DO NOT MODIFY THIS FILE MANUALLY
 *
 *  This file is automatically generated from
 *  the method file (extended with *.m).
 *
 */

#include <vxWorks.h>
#include <hwif/vxBus.h>
#include <subsys/int/vxbIntLib.h>
#include <hwif/methods/vxbIntMethod.h>

VXB_DEVMETHOD_DEF(vxbIntConfig, "VxBus config the interrupt pin");

STATUS VXB_INT_CONFIG (VXB_DEV_ID pDev, UINT32 vector, VXB_INTR_ENTRY * pVxbIntrEntry)
    {
    vxbIntConfig_t * func = (vxbIntConfig_t *) vxbDevMethodFind (pDev, VXB_DEVMETHOD_CALL(vxbIntConfig));

    if (func == NULL)
        return (STATUS)ERROR;

    return func (pDev, vector, pVxbIntrEntry);
    }


VXB_DEVMETHOD_DEF(vxbIntUnconfig, "VxBus unconfig the interrupt pin");

STATUS VXB_INT_UNCONFIG (VXB_DEV_ID pDev, UINT32 vector, VXB_INTR_ENTRY * pVxbIntrEntry)
    {
    vxbIntUnconfig_t * func = (vxbIntUnconfig_t *) vxbDevMethodFind (pDev, VXB_DEVMETHOD_CALL(vxbIntUnconfig));

    if (func == NULL)
        return (STATUS)ERROR;

    return func (pDev, vector, pVxbIntrEntry);
    }


VXB_DEVMETHOD_DEF(vxbIntEnable, "VxBus enable the interrupt pin");

STATUS VXB_INT_ENABLE (VXB_DEV_ID pDev, UINT32 vector, VXB_INTR_ENTRY * pVxbIntrEntry)
    {
    vxbIntEnable_t * func = (vxbIntEnable_t *) vxbDevMethodFind (pDev, VXB_DEVMETHOD_CALL(vxbIntEnable));

    if (func == NULL)
        return (STATUS)ERROR;

    return func (pDev, vector, pVxbIntrEntry);
    }


VXB_DEVMETHOD_DEF(vxbIntDisable, "VxBus disable the interrupt pin");

STATUS VXB_INT_DISABLE (VXB_DEV_ID pDev, UINT32 vector, VXB_INTR_ENTRY * pVxbIntrEntry)
    {
    vxbIntDisable_t * func = (vxbIntDisable_t *) vxbDevMethodFind (pDev, VXB_DEVMETHOD_CALL(vxbIntDisable));

    if (func == NULL)
        return (STATUS)ERROR;

    return func (pDev, vector, pVxbIntrEntry);
    }


VXB_DEVMETHOD_DEF(vxbIntBind, "VxBus bind interrupt to specfic CPU");

STATUS VXB_INT_BIND (VXB_DEV_ID pDev, UINT32 vector, UINT32 cpu, VXB_INTR_ENTRY * pVxbIntrEntry)
    {
    vxbIntBind_t * func = (vxbIntBind_t *) vxbDevMethodFind (pDev, VXB_DEVMETHOD_CALL(vxbIntBind));

    if (func == NULL)
        return (STATUS)ERROR;

    return func (pDev, vector, cpu, pVxbIntrEntry);
    }


VXB_DEVMETHOD_DEF(vxbIntIpi, "VxBus IPI generate function");

STATUS VXB_INT_IPI (VXB_DEV_ID pDev, UINT32 vector, phys_cpuset_t phys_cpus)
    {
    vxbIntIpi_t * func = (vxbIntIpi_t *) vxbDevMethodFind (pDev, VXB_DEVMETHOD_CALL(vxbIntIpi));

    if (func == NULL)
        return (STATUS)ERROR;

    return func (pDev, vector, phys_cpus);
    }


VXB_DEVMETHOD_DEF(vxbIntVecSet, "Perform driver-specific vector setup");

STATUS VXB_INT_VEC_SET (VXB_DEV_ID pDev, UINT32 vector, VXB_INTR_ENTRY * pVxbIntrEntry, VOIDFUNCPTR pFunc, void * pArg)
    {
    vxbIntVecSet_t * func = (vxbIntVecSet_t *) vxbDevMethodFind (pDev, VXB_DEVMETHOD_CALL(vxbIntVecSet));

    if (func == NULL)
        return (STATUS)ERROR;

    return func (pDev, vector, pVxbIntrEntry, pFunc, pArg);
    }


VXB_DEVMETHOD_DEF(vxbIntVecClear, "PErform driver-specific vector teardown");

STATUS VXB_INT_VEC_CLEAR (VXB_DEV_ID pDev, UINT32 vector, VXB_INTR_ENTRY * pVxbIntrEntry, VOIDFUNCPTR pFunc, void * pArg)
    {
    vxbIntVecClear_t * func = (vxbIntVecClear_t *) vxbDevMethodFind (pDev, VXB_DEVMETHOD_CALL(vxbIntVecClear));

    if (func == NULL)
        return (STATUS)ERROR;

    return func (pDev, vector, pVxbIntrEntry, pFunc, pArg);
    }


